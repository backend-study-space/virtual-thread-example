# virtual-thread-example

# 기존 자바 스레드 모델

자바의 스레드 모델은 오랜 기간 동안 운영체제(OS)의 커널 스레드와 1:1 매핑되는 방식을 사용해왔습니다.

  이는 스레드 생성 시 자바의 네이티브 메서드를 호출하여, 시스템 호출을 통해 커널 스레드와 직접적으로 연결하는 과정을 포함합니다.

가상 스레드 도입 전 스레드의 호출 과정은 다음 코드와 같습니다.

![image1](/virtual-thread/code1.png)

![image2](/virtual-thread/code2.png)

해당 과정을 그림으로 설명하면 다음과 같습니다.

![image1](/virtual-thread/1.webp) 

이러한 접근 방식은 스레드 생성 비용이 상대적으로 높다는 단점을 가지고 있었습니다. 
  하나의 스레드가 대략 1 ~ 2MB의 스택 사이즈를 차지함에 따라, 힙 메모리를 4GB로 설정한 자바 애플리케이션은 최대 4000개의 스레드만을 생성할 수 있는 제약을 가지게 됩니다.

스프링과 같은 자바의 대표적인 웹 개발 프레임워크는 멀티 스레드 기반으로, 하나의 요청당 하나의 스레드를 할당하는 방식을 채택하고 있습니다. 

  요청이 증가함에 따라 신규 스레드를 생성하는 과정에서 발생하는 지연은 불가피한 문제로 여겨졌으며, 
  
  이를 해결하기 위해 스프링은 톰캣 스레드풀에 미리 스레드를 생성하여 할당하는 방법을 사용합니다. 
  
  그러나 이 방법 역시 스레드 생성과 관리에 따른 오버헤드가 발생합니다.
  이는 스프링 서버의 레이턴시 지연의 큰 이유 중 하나입니다.

컨텍스트 스위칭 비용도 상당히 큰 부담으로 작용합니다. 
스레드 크기가 경량이 아니며, 컨텍스트 스위칭을 위해 OS 레벨까지 내려가는 네이티브 메서드 호출이 필요하기 때문입니다. 이러한 비용은 Go 언어의 고루틴 같은 경량 스레드 모델과 비교했을 때 상당히 높습니다.

# 가상 스레드 모델의 도입

JEP 444는 자바 플랫폼에 새로운 경량 스레드, 가상 스레드(Virtual Thread, 이하 VT)를 도입했습니다. 
  아키텍처 구조는 다음 이미지와 같습니다.

![image1](/virtual-thread/2.webp) 

자바 힙 메모리에 Virtual Thread(이하 VT)가 대기하고 있는게 보이는데, 다수의 VT는 하나의 플랫폼 스레드(이하 PT)와 매핑될 수 있기 때문에, 

  기존에 비해 상대적으로 적은 PT를 생성해도 더 많은 요청을 수용할 수 있게 됩니다.

VT는 다음과 같이 PT에 마운트 됩니다.

![image1](/virtual-thread/3.webp) 

VT는 컨텍스트 스위칭 비용이 매우 낮다는 장점을 가지고 있습니다. 

기존의 스레드 모델과 다르게, 컨텍스트 스위칭이 빠른 이유는 우선, VT간 컨텍스트 스위칭에는 OS 레벨까지 내려갈 필요가 없는 점이 가장 큰 이유입니다.

기존의 자바 스레드 모델이 LockSupport.class를 통해 네이티브 메서드로 컨텍스트 스위칭을 제공했다면, VT는 park/unpark 개념을 코드로 구현함으로써, carrier Thread(PT)를 통해 다른 VT로 전환하는 것이 가능합니다.

VT의 크기는 기존 스레드 모델에 비해 1%밖에 되지 않아, 메모리 사용량 측면에서도 효율적입니다.

VT의 동작 원리는 다음과 같습니다.

![image1](/virtual-thread/4.png) 

1. 실행될 virtual thread의 작업인 runContinuation을 carrier thread의 workQueue에 push 합니다.
2. Work queue에 있는 runContinuation들은 forkJoinPool에 의해 work stealing 방식으로 carrier thread에 의해 처리됩니다.
3. 처리되던 runContinuation들은 I/O, Sleep으로 인한 interrupt나 작업 완료 시, work queue에서 pop되어 park과정에 의해 다시 힙 메모리로 되돌아갑니다.

기존의 스레드 모델에서 virtual thread의 park, unpark 동작을 통해 virtual thread의 컨텍스트 스위칭을 하는 형태로 동작한다는 것을 알 수 있습니다.

# 주의사항

VT를 사용함에 있어 주의사항은 다음과 같습니다.

## Cpu bound

- 문제점: CPU 연산 작업 시, 일반적인 자바 스레드 모델에 비해 VT 사용이 성능이 떨어질 수 있습니다.
- 이유: CPU 연산은 커널 스레드를 통해 이루어지기 때문에, VT 생성은 되려 불필요한 메모리를 차지하며, 결국 일반 스레드 모델보다 처리 속도가 느려집니다.

## Pinned issue

- 문제점: VT 내에서 synchronized 키워드나 네이티브 메서드 사용 시, PT(플랫폼 스레드)가 락에 걸립니다. 이로 인해 해당 PT를 마운트해야 하는 VT도 함께 블록됩니다.
- 해결 방법: synchronized 사용 대신, 자바의 ReentrantLock을 사용하는 것이 좋습니다. ReentrantLock은 네이티브 메서드를 통한 락 구현이 아니므로 블록되지 않습니다.
- 주의사항: 어플리케이션의 비즈니스 로직이나 사용하는 3rd party 라이브러리 내부에 synchronized 패턴이 있는지 확인 후 사용해야 합니다.

## 스레드 풀의 사용 여부

- 문제점: VT는 생성 비용이 매우 낮기 때문에, 스레드 풀을 사용하는 것은 오히려 자원 낭비가 될 수 있습니다.
- 권장 사항: 한 번 사용 후 GC에 의해 소거되도록 하는 것이 더 바람직합니다.

## 예제

- 목적: VT 도입 후 BufferedWriter 클래스의 내부 구현이 어떻게 변경되었는지 확인하고, 기존 스레드 모델을 사용해 스레드풀로 non-blocking 방식을 수행했을 때와 VT를 사용한 수행의 차이를 알아보겠습니다.

## 참고 자료

- https://techblog.woowahan.com/15398/#toc-4
- https://blog.stackademic.com/java-threading-essentials-virtual-vs-platform-threads-explained-32365d8f92be
